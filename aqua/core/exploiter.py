import paramiko
import requests
import socket
import subprocess
from typing import Optional, Dict, Any
import json
from pathlib import Path
import logging
from dataclasses import dataclass
from datetime import datetime

@dataclass
class ExploitResult:
    success: bool
    output: str
    error: Optional[str] = None
    timestamp: datetime = None

class IoTPTFExploiter:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.exploit_db = self._load_exploit_db()
        
    def _load_exploit_db(self) -> Dict:
        db_path = Path(__file__).parent / "data" / "exploits.json"
        if db_path.exists():
            with open(db_path) as f:
                return json.load(f)
        return {}
    
    def exploit(self, target: str, vulnerability: str, **kwargs) -> ExploitResult:
        """Exploit a vulnerability on a target."""
        try:
            # Check if we have an exploit for this vulnerability
            if vulnerability in self.exploit_db:
                exploit_info = self.exploit_db[vulnerability]
                exploit_type = exploit_info.get('type', '')
                
                if exploit_type == 'ssh':
                    return self._exploit_ssh(target, exploit_info, **kwargs)
                elif exploit_type == 'http':
                    return self._exploit_http(target, exploit_info, **kwargs)
                elif exploit_type == 'custom':
                    return self._run_custom_exploit(target, exploit_info, **kwargs)
                else:
                    return ExploitResult(
                        success=False,
                        output="",
                        error=f"Unsupported exploit type: {exploit_type}"
                    )
            else:
                return ExploitResult(
                    success=False,
                    output="",
                    error=f"No exploit found for vulnerability: {vulnerability}"
                )
        except Exception as e:
            return ExploitResult(
                success=False,
                output="",
                error=str(e)
            )
    
    def _exploit_ssh(self, target: str, exploit_info: Dict[str, Any], **kwargs) -> ExploitResult:
        """Exploit SSH-related vulnerabilities."""
        try:
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Get credentials from kwargs or use defaults
            username = kwargs.get('username', 'root')
            password = kwargs.get('password', 'password')
            port = kwargs.get('port', 22)
            
            client.connect(target, port=port, username=username, password=password, timeout=10)
            
            # Execute the exploit command
            command = exploit_info.get('command', 'id')
            stdin, stdout, stderr = client.exec_command(command)
            
            output = stdout.read().decode()
            error = stderr.read().decode()
            
            client.close()
            
            return ExploitResult(
                success=True,
                output=output,
                error=error if error else None,
                timestamp=datetime.now()
            )
        except Exception as e:
            return ExploitResult(
                success=False,
                output="",
                error=str(e),
                timestamp=datetime.now()
            )
    
    def _exploit_http(self, target: str, exploit_info: Dict[str, Any], **kwargs) -> ExploitResult:
        """Exploit HTTP-related vulnerabilities."""
        try:
            method = exploit_info.get('method', 'GET')
            path = exploit_info.get('path', '/')
            headers = exploit_info.get('headers', {})
            data = exploit_info.get('data', None)
            
            url = f"http://{target}{path}"
            
            if method.upper() == 'GET':
                response = requests.get(url, headers=headers, timeout=10)
            elif method.upper() == 'POST':
                response = requests.post(url, headers=headers, data=data, timeout=10)
            else:
                return ExploitResult(
                    success=False,
                    output="",
                    error=f"Unsupported HTTP method: {method}",
                    timestamp=datetime.now()
                )
            
            return ExploitResult(
                success=response.status_code == 200,
                output=response.text,
                error=None if response.status_code == 200 else f"HTTP {response.status_code}",
                timestamp=datetime.now()
            )
        except Exception as e:
            return ExploitResult(
                success=False,
                output="",
                error=str(e),
                timestamp=datetime.now()
            )
    
    def _run_custom_exploit(self, target: str, exploit_info: Dict[str, Any], **kwargs) -> ExploitResult:
        """Run a custom exploit script."""
        try:
            script_path = Path(__file__).parent / "exploits" / exploit_info.get('script', '')
            if not script_path.exists():
                return ExploitResult(
                    success=False,
                    output="",
                    error=f"Exploit script not found: {script_path}",
                    timestamp=datetime.now()
                )
            
            # Make the script executable
            script_path.chmod(0o755)
            
            # Run the exploit
            process = subprocess.Popen(
                [str(script_path), target],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            stdout, stderr = process.communicate()
            
            return ExploitResult(
                success=process.returncode == 0,
                output=stdout.decode(),
                error=stderr.decode() if stderr else None,
                timestamp=datetime.now()
            )
        except Exception as e:
            return ExploitResult(
                success=False,
                output="",
                error=str(e),
                timestamp=datetime.now()
            ) 